---@diagnostic disable: duplicate-set-field

local async = require("plenary.async")
local assert = require("luassert")

describe("jobs", function()
    local jobs = require("TreeFiddyGit.jobs")
    describe("get_git_root_path", function()
        local original_get_git_worktree_reference = jobs._get_git_worktree_reference
        local original_is_in_bare_repo = jobs._in_bare_repo
        local original_get_pwd = jobs._get_pwd

        after_each(function()
            jobs._get_git_worktree_reference = original_get_git_worktree_reference
            jobs._in_bare_repo = original_is_in_bare_repo
            jobs._get_pwd = original_get_pwd
        end)

        async.tests.it("should return the git root path when inside a worktree", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/home/user/gitrepo.git/worktrees/main" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/home/user/gitrepo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should return the error generated by get_git_worktree_reference if that fails", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback(nil, "Some error generated by get_git_worktree_reference")
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.is_nil(result)
            assert.are.equal("Some error generated by get_git_worktree_reference", err)
        end)

        describe("when get_git_worktree_reference returns '.'", function()
            async.tests.it("should return the error thrown by is_bare if it fails", function()
                jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                    callback({ "." }, nil)
                end)
                jobs._in_bare_repo = vim.schedule_wrap(function(callback)
                    callback(nil, "Some error thrown by is_bare")
                end)

                local result, err = async.wrap(jobs.get_git_root_path, 1)()
                assert.is_nil(result)
                assert.are.equal("Some error thrown by is_bare", err)
            end)

            async.tests.it("should return not supported error if is_bare returns false", function()
                jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                    callback({ "." }, nil)
                end)
                jobs._in_bare_repo = vim.schedule_wrap(function(callback)
                    callback({ "false" }, nil)
                end)

                local result, err = async.wrap(jobs.get_git_root_path, 1)()
                assert.is_nil(result)
                assert.are.equal("Not in a supported git repository", err)
            end)

            async.tests.it("should return pwd if is_bare returns true", function()
                jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                    callback({ "." }, nil)
                end)
                jobs._in_bare_repo = vim.schedule_wrap(function(callback)
                    callback({ "true" }, nil)
                end)
                jobs._get_pwd = vim.schedule_wrap(function(callback)
                    callback({ "the/path/returned/by/pwd.git" }, nil)
                end)

                local result, err = async.wrap(jobs.get_git_root_path, 1)()
                assert.are.equal("the/path/returned/by/pwd.git", result)
                assert.is_nil(err)
            end)

            async.tests.it("should throw error thrown by pwd if it fails", function()
                jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                    callback({ "." }, nil)
                end)
                jobs._in_bare_repo = vim.schedule_wrap(function(callback)
                    callback({ "true" }, nil)
                end)
                jobs._get_pwd = vim.schedule_wrap(function(callback)
                    callback(nil, "Some pwd error")
                end)

                local result, err = async.wrap(jobs.get_git_root_path, 1)()
                assert.is_nil(result)
                assert.are.equal("Some pwd error", err)
            end)
        end)

        async.tests.it("should parse the root if get_git_worktree_reference returns a worktree", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktrees/main" })
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/some/path/to/a_project_repo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should parse the root if get_git_worktree_reference returns a nested worktree", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktrees/main/some/deeply/nested/tree" })
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/some/path/to/a_project_repo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should parse the root if get_git_worktree_reference returns the worktree directory path", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktrees" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/some/path/to/a_project_repo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should handle having multiple .git/worktrees in the path", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktrees/branch.git/worktrees/whoop" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/some/path/to/a_project_repo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should handle having .git in the branch name", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktrees/branch.git" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.are.equal("/some/path/to/a_project_repo.git", result)
            assert.is_nil(err)
        end)

        async.tests.it("should error if the worktree path is invalid", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ "/some/path/to/a_project_repo.git/worktreess" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.is_nil(result)
            assert.are.equal("Failed to get git root path", err)
        end)

        async.tests.it("should fail when in a treeless git repo", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ ".git" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.is_nil(result)
            assert.are.equal("Must be in a bare repo", err)
        end)

        async.tests.it("should fail when in a root dir called \".git/worktrees\"", function()
            jobs._get_git_worktree_reference = vim.schedule_wrap(function(callback)
                callback({ ".git/worktrees" }, nil)
            end)

            local result, err = async.wrap(jobs.get_git_root_path, 1)()
            assert.is_nil(result)
            assert.are.equal("Failed to get git root path", err)
        end)
    end)
end)
